<!doctype html>
<html lang="no">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Synsanalyse ‚Äì Rest-defokus & Monovision/Presbyond</title>
<style>
  :root {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    --color-right: #0a7;
    --color-left: #c22;
    --color-right-bg: rgba(0, 170, 119, 0.08);
    --color-left-bg: rgba(204, 34, 34, 0.08);
  }
  body { margin:0; padding:20px; background:#f8f9fa; color:#111; }
  .wrap { max-width: 1200px; margin: 0 auto; }
  h1 { font-size: 24px; margin: 0 0 8px; font-weight: 600; color:#1a1a1a; }
  h2 { font-size: 16px; margin: 20px 0 10px; font-weight: 600; color:#333; }
  h3 { font-size: 14px; margin: 0 0 8px; font-weight: 600; color:#444; }
  .intro { font-size: 14px; color:#555; margin: 0 0 20px; line-height: 1.6; background:#fff; padding:16px; border-radius:12px; border:1px solid #e0e0e0; }
  .intro strong { color:#333; }
  .card { border:1px solid #e0e0e0; border-radius:12px; padding:18px; margin: 14px 0; background:#fff; box-shadow: 0 1px 3px rgba(0,0,0,0.04); }
  .row { display:grid; grid-template-columns: 1fr; gap:16px; }
  @media (min-width: 980px) { .row { grid-template-columns: 1.15fr 1fr; } }
  .mono { font-variant-numeric: tabular-nums; }
  label { font-size:13px; display:block; margin-bottom:8px; color:#333; font-weight: 500; }
  input[type=range] { width:100%; height:6px; accent-color:#0066cc; margin-bottom:0; }
  .slider-ticks { position:relative; width:100%; height:22px; margin-top:-2px; padding:0 6px 0 9px; box-sizing:border-box; }
  .slider-ticks .tick-line { width:100%; height:12px; }
  .slider-ticks .tick-line svg { width:100%; height:100%; overflow:visible; }
  .slider-ticks .tick-labels { display:flex; justify-content:space-between; margin-top:2px; margin-left:-2.5px; margin-right:3px; }
  .slider-ticks .tick-labels span { font-size:9px; color:#999; font-variant-numeric:tabular-nums; text-align:center; width:0; overflow:visible; white-space:nowrap; }
  .slider-ticks .tick-labels span.zero { color:#333; font-weight:600; }
  .pill { border:1px solid #d0d0d0; padding:3px 10px; border-radius:999px; font-size:13px; display:inline-block; background:#f5f5f5; font-weight:600; }
  .note { background:#f0f7ff; border:1px solid #b3d9ff; border-radius:10px; padding:12px; margin:10px 0; }
  .hint { font-size: 13px; color:#555; line-height: 1.6; }
  .help { font-size: 12px; color:#777; margin-top:4px; font-style:italic; }
  table { width:100%; border-collapse:collapse; margin-top:12px; }
  th, td { padding:10px 8px; border-bottom:1px solid #e8e8e8; font-size:13px; text-align:left; vertical-align: top; }
  th { font-size:12px; color:#666; font-weight:600; background:#f8f8f8; text-transform:uppercase; letter-spacing:0.3px; }
  tbody tr:hover { background:#fafafa; }
  .good { font-weight: 700; }
  .small { font-size:12px; color:#666; margin-top:3px; line-height:1.3; }
  canvas { width:100%; height:180px; border:1px solid #e0e0e0; border-radius:10px; background:#fff; }
  .chart-stack { display:grid; grid-template-columns: 1fr; gap:12px; }
  .controls { display:grid; gap: 14px; }
  .toggleRow { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
  .smallInput { width: 170px; padding: 7px 10px; border:1px solid #d0d0d0; border-radius:8px; font-size:13px; }
  .badge { background:#e8f4f8; border:1px solid #b8dce8; border-radius:10px; padding:10px; font-size:13px; }
  .section-title { font-size:15px; font-weight:600; color:#444; margin:0 0 12px; padding-bottom:8px; border-bottom:2px solid #e0e0e0; }
  .eye-card { border:1px solid #e0e0e0; border-radius:10px; padding:14px; }
  .eye-card.right { border-left: 3px solid var(--color-right); background: var(--color-right-bg); }
  .eye-card.left { border-left: 3px solid var(--color-left); background: var(--color-left-bg); }
  .eye-label-right { color: var(--color-right); font-weight: 600; }
  .eye-label-left { color: var(--color-left); font-weight: 600; }
  .age-estimate { display:flex; align-items:center; gap:6px; color:#0066cc; font-size:13px; font-weight:500; margin-top:6px; }
  .chart-title { font-size:14px; font-weight:600; margin:0 0 8px; display:flex; align-items:center; gap:6px; }
  .chart-title.right { color: var(--color-right); }
  .chart-title.left { color: var(--color-left); }
  .eye-fields { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  @media (max-width: 500px) { .eye-fields { grid-template-columns: 1fr; } }
</style>
</head>
<body>
<div class="wrap">

<h1>üëÅÔ∏è Synsanalyse</h1>

<div class="intro">
  <strong>Hva er dette?</strong> Denne kalkulatoren simulerer hvordan √∏ynene dine ser p√• ulike avstander etter refraktiv kirurgi (LASIK, PRK, SMILE).
  Du kan justere <strong>startverdien</strong> (√∏yets naturlige brille-styrke), <strong>linseverdien</strong> (korreksjon via kirurgi/linser),
  og <strong>akkommodasjon</strong> (√∏yets evne til √• fokusere). Resultatet viser <strong>rest-defokus</strong>: hvor uskarp synet blir p√• ulike avstander.
  <br><br>
  <strong>Monovision/Presbyond:</strong> En teknikk der ett √∏ye korrigeres for avstand (dominant) og det andre for n√¶rarbeid,
  nyttig for personer over 40‚Äì45 √•r som mister akkommodasjon (presbyopi).
</div>

<div class="card">
<h2 class="section-title">‚öôÔ∏è Innstillinger</h2>
<div class="row">
<div class="controls">

<!-- Right eye first (consistent with iOS) -->
<div class="eye-card right">
<h3 class="chart-title right">üëÅÔ∏è H√∏yre √∏ye</h3>
<div class="eye-fields">
<div>
<label>Startverdi (R0): <span id="rRightVal" class="pill mono"></span></label>
<input id="rRight" type="range" min="-8" max="8" step="0.25" value="0"/>
<div class="slider-ticks" data-min="-8" data-max="8"></div>
<div class="help">√òyets naturlige brille-styrke (+ = langsynthet, ‚àí = n√¶rsynt)</div>
</div>
<div>
<label>Linseverdi (Korreksjon): <span id="lensRightVal" class="pill mono"></span></label>
<input id="lensRight" type="range" min="-8" max="8" step="0.25" value="0"/>
<div class="slider-ticks" data-min="-8" data-max="8"></div>
<div class="help">Korreksjon via kirurgi/linser</div>
</div>
</div>
</div>

<div class="eye-card left">
<h3 class="chart-title left">üëÅÔ∏è Venstre √∏ye</h3>
<div class="eye-fields">
<div>
<label>Startverdi (R0): <span id="rLeftVal" class="pill mono"></span></label>
<input id="rLeft" type="range" min="-8" max="8" step="0.25" value="0"/>
<div class="slider-ticks" data-min="-8" data-max="8"></div>
<div class="help">√òyets naturlige brille-styrke (+ = langsynthet, ‚àí = n√¶rsynt)</div>
</div>
<div>
<label>Linseverdi (Korreksjon): <span id="lensLeftVal" class="pill mono"></span></label>
<input id="lensLeft" type="range" min="-8" max="8" step="0.25" value="0"/>
<div class="slider-ticks" data-min="-8" data-max="8"></div>
<div class="help">Korreksjon via kirurgi/linser</div>
</div>
</div>
</div>

<div>
<label>Akkommodasjon (A): <span id="accVal" class="pill mono"></span></label>
<input id="accommodation" type="range" min="0" max="12" step="0.25" value="12"/>
<div class="age-estimate" id="ageEstimate">üë§ Gjennomsnittsalder: ~22 √•r</div>
<div class="help">√òyets evne til √• fokusere p√• n√¶rt hold (reduseres med alderen). Basert p√• Hofstetters gjennomsnitt.</div>
</div>

<div style="border-top:1px solid #e0e0e0; padding-top:16px; margin-top:8px;">
<h3 style="font-size:14px; margin:0 0 10px; color:#333;">‚öôÔ∏è Monovision / Presbyond</h3>
<div class="toggleRow">
<label style="display:flex; align-items:center; gap:6px;">
  <input type="checkbox" id="monoToggle" style="width:auto; height:auto;"/>
  <span>Aktiver Monovision / Presbyond</span>
</label>

<label>Dominant √∏ye:
<select id="dominantEye" class="smallInput">
<option value="R" selected>H√∏yre</option>
<option value="L">Venstre</option>
</select>
</label>

<label>M√•l residual for n√¶r√∏ye:
<input type="number" id="nearResidualTarget" class="smallInput mono" value="-1.25" step="0.25"/>
</label>

<span id="eyeSummary" class="pill mono"></span>
</div>

<div class="badge hint mono" id="dominantCalc"></div>
</div>

</div>

<div>
<h2 class="section-title">üìä Resultater</h2>
<div id="summary" class="mono good" style="margin-bottom:8px;"></div>

<table class="mono">
<thead>
<tr>
<th>√òye</th>
<th>Residual (R)<br><span style="font-weight:normal; font-size:11px;">Etter korreksjon</span></th>
<th>Avstand</th>
<th>1/d (Krav)<br><span style="font-weight:normal; font-size:11px;">Dioptrier n√∏dvendig</span></th>
<th>Rest-defokus<br><span style="font-weight:normal; font-size:11px;">Uskarpheten (0 = skarpt)</span></th>
</tr>
</thead>
<tbody id="resultTable"></tbody>
</table>
</div>
</div>

<div class="card">
<h2 class="section-title">üìà Visuell fremstilling av rest-defokus</h2>
<div class="note hint">
  <strong>Hvordan lese grafen:</strong> X-aksen viser rest-defokus i dioptrier (D).
  Verdier n√¶r 0 D betyr skarp visjon. Jo st√∏rre avstand fra 0, jo mer uskarp blir visningen.
  <br><br>
  <strong>üîµ Lysbl√•tt omr√•de = DOF (Depth of Field):</strong> Det skraverte lysbl√• omr√•det viser fokusomr√•det hvor synet er akseptabelt skarpt.
  <br>‚Ä¢ <strong>Uten Monovision/Presbyond:</strong> ¬±0.50 D (standard fokusomr√•de)
  <br>‚Ä¢ <strong>Med Monovision/Presbyond:</strong> ¬±1.25 D (utvidet fokusomr√•de)
  <br><br>
  <strong>Da finnes tre situasjoner:</strong>
  <br>1Ô∏è‚É£ <strong>Myopi (‚àí):</strong> Fokus foran netthinnen ‚Üí bildet er uklart p√• avstand
  <br>2Ô∏è‚É£ <strong>Hyperopi (+):</strong> Fokus bak netthinnen ‚Üí bildet er uklart p√• avstand (uten akkommodasjon)
  <br>3Ô∏è‚É£ <strong>Plano (0):</strong> Fokus p√• netthinnen ‚Üí skarpt p√• avstand
</div>
<!-- Charts: Right eye first, stacked vertically (consistent with iOS) -->
<div class="chart-stack">
<div>
<h3 class="chart-title right">üëÅÔ∏è H√∏yre √∏ye</h3>
<canvas id="canvasRight"></canvas>
</div>
<div>
<h3 class="chart-title left">üëÅÔ∏è Venstre √∏ye</h3>
<canvas id="canvasLeft"></canvas>
</div>
</div>
</div>

</div>

<script>

// Generate slider tick marks
document.querySelectorAll('.slider-ticks').forEach(el => {
  const min = parseFloat(el.dataset.min);
  const max = parseFloat(el.dataset.max);
  const range = max - min;
  const totalSteps = range / 0.5; // steps of 0.5
  const insetPct = 0; // no SVG inset ‚Äî padding on container handles alignment

  // SVG tick lines
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('viewBox', '0 0 100 12');
  svg.setAttribute('preserveAspectRatio', 'none');
  const usable = 100;

  // Horizontal line
  const hLine = document.createElementNS(svgNS, 'line');
  hLine.setAttribute('x1', 0); hLine.setAttribute('y1', 0);
  hLine.setAttribute('x2', 100); hLine.setAttribute('y2', 0);
  hLine.setAttribute('stroke', '#aaa'); hLine.setAttribute('stroke-width', '0.15');
  svg.appendChild(hLine);

  for (let i = 0; i <= totalSteps; i++) {
    const value = min + i * 0.5;
    const x = usable * (i / totalSteps);
    let h;
    if (value % 2 === 0) h = 10;       // labeled (even): tallest
    else if (value % 1 === 0) h = 6;    // odd integers: medium
    else h = 3;                          // half steps: shortest
    const tick = document.createElementNS(svgNS, 'line');
    tick.setAttribute('x1', x); tick.setAttribute('y1', 0);
    tick.setAttribute('x2', x); tick.setAttribute('y2', h);
    tick.setAttribute('stroke', '#aaa'); tick.setAttribute('stroke-width', '0.15');
    svg.appendChild(tick);
  }

  const tickDiv = document.createElement('div');
  tickDiv.className = 'tick-line';
  tickDiv.appendChild(svg);
  el.appendChild(tickDiv);

  // Labels for even integers only
  const labelsDiv = document.createElement('div');
  labelsDiv.className = 'tick-labels';
  for (let v = min; v <= max; v += 2) {
    const span = document.createElement('span');
    span.textContent = v > 0 ? '+' + v : '' + v;
    if (v === 0) span.className = 'zero';
    labelsDiv.appendChild(span);
  }
  el.appendChild(labelsDiv);
});

const distances = [
  { name: "Fjern (‚àû)", d: Infinity },
  { name: "Mellom (70 cm)", d: 0.70 },
  { name: "N√¶r (40 cm)", d: 0.40 },
];

const rRight = document.getElementById("rRight");
const rLeft = document.getElementById("rLeft");
const lensRight = document.getElementById("lensRight");
const lensLeft = document.getElementById("lensLeft");
const acc = document.getElementById("accommodation");
const monoToggle = document.getElementById("monoToggle");
const dominantEye = document.getElementById("dominantEye");
const nearResidualTargetEl = document.getElementById("nearResidualTarget");

const rRightVal = document.getElementById("rRightVal");
const rLeftVal = document.getElementById("rLeftVal");
const lensRightVal = document.getElementById("lensRightVal");
const lensLeftVal = document.getElementById("lensLeftVal");
const accVal = document.getElementById("accVal");
const ageEstimate = document.getElementById("ageEstimate");

const summary = document.getElementById("summary");
const eyeSummary = document.getElementById("eyeSummary");
const dominantCalc = document.getElementById("dominantCalc");
const resultTable = document.getElementById("resultTable");

const canvasRight = document.getElementById("canvasRight");
const canvasLeft = document.getElementById("canvasLeft");
const ctxRight = canvasRight.getContext("2d");
const ctxLeft = canvasLeft.getContext("2d");
const STORAGE_KEY = "synsmodellState.v1";

function saveState(){
  const state = {
    rRight: rRight.value,
    rLeft: rLeft.value,
    lensRight: lensRight.value,
    lensLeft: lensLeft.value,
    accommodation: acc.value,
    monoToggle: monoToggle.checked,
    dominantEye: dominantEye.value,
    nearResidualTarget: nearResidualTargetEl.value
  };

  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }catch(_e){
  }
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;

    const state = JSON.parse(raw);
    if(!state || typeof state !== "object") return;

    if(state.rRight !== undefined) rRight.value = state.rRight;
    if(state.rLeft !== undefined) rLeft.value = state.rLeft;
    if(state.lensRight !== undefined) lensRight.value = state.lensRight;
    if(state.lensLeft !== undefined) lensLeft.value = state.lensLeft;
    if(state.accommodation !== undefined) acc.value = state.accommodation;
    monoToggle.checked = Boolean(state.monoToggle);
    if(state.dominantEye === "R" || state.dominantEye === "L") dominantEye.value = state.dominantEye;
    if(state.nearResidualTarget !== undefined) nearResidualTargetEl.value = state.nearResidualTarget;
  }catch(_e){
  }
}

function fmt(x){return (x>0?"+":"")+x.toFixed(2)+" D";}
function demand(d){return d===Infinity?0:1/d;}

function optimalLens(R0,d,A){
  const B = R0 + demand(d);
  const cov = B>0 ? Math.min(B,A) : 0;
  return B - cov;
}

function restDefocus(R,d,A){
  const B = R + demand(d);
  const cov = B>0 ? Math.min(B,A) : 0;
  return B - cov;
}

/** Hofstetter's average formula: A = 18.5 - 0.3 * age => age = (18.5 - A) / 0.3 */
function estimatedAgeFromAcc(A) {
  const age = (18.5 - A) / 0.3;
  return Math.max(10, Math.min(70, Math.round(age)));
}

function update(){

  const RR0 = parseFloat(rRight.value);
  const RL0 = parseFloat(rLeft.value);
  let lensR = parseFloat(lensRight.value);
  let lensL = parseFloat(lensLeft.value);
  const A = parseFloat(acc.value);

  rRightVal.textContent = fmt(RR0);
  rLeftVal.textContent = fmt(RL0);

  // Update age estimate
  ageEstimate.textContent = "\u{1F464} Gjennomsnittsalder: ~" + estimatedAgeFromAcc(A) + " \u00E5r";

  let RR, RL;
  let dominant = "H\u00F8yre";
  let nearEye = "Venstre";

  if(monoToggle.checked){
    const nearTarget = parseFloat(nearResidualTargetEl.value);

    if(dominantEye.value==="R"){
      dominant="H\u00F8yre";
      nearEye="Venstre";

      RR = RR0 - lensR;
      lensL = RL0 - nearTarget;
      RL = nearTarget;

      lensLeft.disabled = true;
      lensRight.disabled = false;
      lensLeft.style.opacity = "0.5";
      lensRight.style.opacity = "1";

      eyeSummary.innerHTML = '<span class="eye-label-left">Venstre: '+fmt(RL)+' (n\u00E6r\u00F8ye)</span> \u00B7 <span class="eye-label-right">H\u00F8yre: '+fmt(RR)+' (dominant)</span>';
    }else{
      dominant="Venstre";
      nearEye="H\u00F8yre";

      RL = RL0 - lensL;
      lensR = RR0 - nearTarget;
      RR = nearTarget;

      lensRight.disabled = true;
      lensLeft.disabled = false;
      lensRight.style.opacity = "0.5";
      lensLeft.style.opacity = "1";

      eyeSummary.innerHTML = '<span class="eye-label-left">Venstre: '+fmt(RL)+' (dominant)</span> \u00B7 <span class="eye-label-right">H\u00F8yre: '+fmt(RR)+' (n\u00E6r\u00F8ye)</span>';
    }

    dominantCalc.textContent = "Dominant \u00F8ye kan justeres fritt. N\u00E6r\u00F8ye beregnes automatisk til "+fmt(nearTarget)+".";
  }else{
    lensR = parseFloat(lensRight.value);
    lensL = parseFloat(lensLeft.value);
    RR = RR0 - lensR;
    RL = RL0 - lensL;

    lensRight.disabled = false;
    lensLeft.disabled = false;
    lensRight.style.opacity = "1";
    lensLeft.style.opacity = "1";

    eyeSummary.textContent = "Ingen monovision";
    dominantCalc.textContent = "";
  }

  lensRightVal.textContent = fmt(lensR);
  lensLeftVal.textContent = fmt(lensL);
  accVal.textContent = fmt(A);

  summary.textContent = "";
  resultTable.innerHTML="";

  const graphData = { right: [], left: [] };

  // Right eye first (consistent with iOS)
  const eyes = [
    {label:"H\u00F8yre", R0:RR0, R:RR, cssClass:"eye-label-right"},
    {label:"Venstre", R0:RL0, R:RL, cssClass:"eye-label-left"}
  ];

  for(const e of eyes){
    const P = e.R0 - e.R;

    for(const dist of distances){
      let lensShown;
      let rest;
      const isDominant = monoToggle.checked && e.label===dominant;

      if(monoToggle.checked){
        if(isDominant){
          lensShown = optimalLens(e.R0,dist.d,A);
          rest = restDefocus(e.R,dist.d,A);
        }else{
          lensShown = P;
          rest = restDefocus(e.R,dist.d,A);
        }
      }else{
        lensShown = optimalLens(e.R0,dist.d,A);
        rest = restDefocus(e.R,dist.d,A);
      }

      if(e.label==="H\u00F8yre"){
        graphData.right.push({dist: dist.name, value: rest});
      }else{
        graphData.left.push({dist: dist.name, value: rest});
      }

      const tr=document.createElement("tr");
      const residualShown = dist.d===Infinity ? fmt(e.R) : "";
      const eyeColor = e.cssClass === "eye-label-right" ? "var(--color-right)" : "var(--color-left)";
      tr.innerHTML=
        '<td><strong style="color:'+eyeColor+'">'+e.label+'</strong></td>'+
        '<td>'+residualShown+'</td>'+
        '<td>'+dist.name+'</td>'+
        '<td>'+fmt(demand(dist.d))+'</td>'+
        '<td><strong style="font-size:15px; color:'+(Math.abs(rest)<0.5?'#0a7':'#c22')+';">'+fmt(rest)+'</strong></td>';
      resultTable.appendChild(tr);
    }
  }

  drawGraph(graphData, monoToggle.checked);
  saveState();
}

function drawGraph(data, isMonovision){
  drawSingleEyeGraph(canvasRight, ctxRight, data.right, "#0a7", "H\u00F8yre", isMonovision);
  drawSingleEyeGraph(canvasLeft, ctxLeft, data.left, "#c22", "Venstre", isMonovision);
}

function drawSingleEyeGraph(canvas, ctx, dataPoints, color, eyeLabel, isMonovision){

  const minX=-6, maxX=6;
  const W=canvas.clientWidth;
  const H=canvas.clientHeight;

  canvas.width=W;
  canvas.height=H;

  ctx.clearRect(0,0,W,H);

  const margin={top:20, right:30, bottom:50, left:90};
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;

  function xToPx(val){
    return margin.left + ((val-minX)/(maxX-minX))*plotW;
  }

  // Y-positions: Fjern at top, N√¶r at bottom (consistent with iOS)
  const yPositions = {
    "Fjern (\u221E)": margin.top + plotH*0.2,
    "Mellom (70 cm)": margin.top + plotH*0.5,
    "N\u00E6r (40 cm)": margin.top + plotH*0.8
  };

  // DOF zone
  const dofRange = isMonovision ? 1.25 : 0.50;
  ctx.fillStyle = "rgba(173, 216, 230, 0.25)";
  const dofLeft = xToPx(-dofRange);
  const dofRight = xToPx(dofRange);
  ctx.fillRect(dofLeft, margin.top, dofRight - dofLeft, plotH);

  // DOF dashed borders
  ctx.strokeStyle = "rgba(100, 149, 237, 0.4)";
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(dofLeft, margin.top);
  ctx.lineTo(dofLeft, margin.top + plotH);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(dofRight, margin.top);
  ctx.lineTo(dofRight, margin.top + plotH);
  ctx.stroke();
  ctx.setLineDash([]);

  // Zero line
  const zeroX = xToPx(0);
  ctx.strokeStyle="#999";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(zeroX, margin.top);
  ctx.lineTo(zeroX, H-margin.bottom);
  ctx.stroke();

  // Zone labels
  ctx.font="12px system-ui";
  ctx.textAlign="center";
  ctx.fillStyle="#555";
  ctx.fillText("Myopi (\u2212)", xToPx(-3), margin.top - 4);
  ctx.fillText("Plano (0)", xToPx(0), margin.top - 4);
  ctx.fillText("Hyperopi (+)", xToPx(3), margin.top - 4);

  // X-axis scale
  ctx.fillStyle="#666";
  ctx.font="11px system-ui";
  ctx.textAlign="center";
  ctx.lineWidth=1;
  for(let i=minX; i<=maxX; i+=2){
    const x = xToPx(i);
    ctx.fillText((i>0?"+":"")+i+" D", x, H-margin.bottom+20);
    ctx.strokeStyle="#f0f0f0";
    ctx.beginPath();
    ctx.moveTo(x, margin.top);
    ctx.lineTo(x, H-margin.bottom);
    ctx.stroke();
  }

  // Y-axis labels
  ctx.textAlign="right";
  ctx.fillStyle="#444";
  ctx.font="12px system-ui";
  Object.entries(yPositions).forEach(([label, y])=>{
    ctx.fillText(label, margin.left-10, y+4);
  });

  // Draw line
  if(dataPoints.length >= 2){
    ctx.strokeStyle=color;
    ctx.lineWidth=3;
    ctx.beginPath();

    dataPoints.forEach((pt, idx)=>{
      const x = xToPx(pt.value);
      const y = yPositions[pt.dist];
      if(idx===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Draw points with value labels
    dataPoints.forEach(pt=>{
      const x = xToPx(pt.value);
      const y = yPositions[pt.dist];
      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI*2);
      ctx.fill();

      // Value annotation
      ctx.font="11px system-ui";
      ctx.textAlign = pt.value >= 0 ? "left" : "right";
      ctx.fillStyle = "#333";
      const offset = pt.value >= 0 ? 10 : -10;
      ctx.fillText(fmt(pt.value), x + offset, y + 4);
    });
  }
}

[rRight,rLeft,lensRight,lensLeft,acc,monoToggle,dominantEye,nearResidualTargetEl].forEach(el=>{
  el.addEventListener("input",update);
  el.addEventListener("change",update);
});

loadState();
update();

</script>
</body>
</html>
